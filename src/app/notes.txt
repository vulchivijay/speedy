
      <div style={{ display: 'flex', gap: 8, marginTop: 8 }}>
        <button
          onClick={start}
          disabled={running}
          style={{ padding: '8px 12px' }}
        >
          Start Test
        </button>
        <button
          onClick={stop}
          disabled={!running}
          style={{ padding: '8px 12px' }}
        >
          Stop
        </button>
        <button
          onClick={reset}
          disabled={running}
          style={{ padding: '8px 12px' }}
        >
          Reset
        </button>
      </div>

      <div style={{ marginTop: 12, color: '#555' }}>{progress}</div>

      {summary}

      <details style={{ marginTop: 16 }}>
        <summary>Notes & Tips</summary>
        <ul>
          <li>Uses browser <code>performance.now()</code> for timing and Web Streams for I/O.</li>
          <li>Server responses set <code>Cache-Control: no-store</code> to avoid caching.</li>
          <li>Measured speeds are approximate; Wiâ€‘Fi, CPU, server/location, and tab throttling can affect results.</li>
          <li>Increase test durations (e.g., 15â€“20s) for more stable readings.</li>
          <li>You can switch API routes to <code>export const runtime = 'edge'</code> for lower latency, but Node is safer for large streams.</li>
        </ul>
      </details>




      
import { DualFullGauges } from "./components/speedGauges";
import SpeedTestLocationDetails from "./components/speedTestLocationDetails";
import SpeedTestMeasureDetails from "./components/speedTestMeasureDetails";

export default function Home() {

  return (
    <div className="flex flex-row items-center justify-center py-2">
      <SpeedTestMeasureDetails />
      <div className="basis-md text-center">
        <div className="basis-4xl m-4">
          <DualFullGauges download={95} upload={38} maxDown={100} maxUp={40} />
        </div>
      </div>
      <SpeedTestLocationDetails />
    </div>
  );
}




'use client';

import { useCallback, useMemo, useRef, useState } from 'react';

function formatBitsPerSecond(bps: number) {
  if (!isFinite(bps) || bps <= 0) return '0 bps';
  const units = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];
  let i = 0;
  let value = bps;
  while (value >= 1000 && i < units.length - 1) {
    value /= 1000;
    i++;
  }
  return `${value.toFixed(2)} ${units[i]}`;
}

function formatMs(ms: number) {
  return `${ms.toFixed(1)} ms`;
}

// Fills any Uint8Array using getRandomValues in 64KB chunks (browser-safe)
function fillRandom(view: Uint8Array) {
  const MAX = 65536; // 64KB per spec
  for (let i = 0; i < view.length; i += MAX) {
    crypto.getRandomValues(view.subarray(i, Math.min(i + MAX, view.length)));
  }
}

export default function Page() {
  const [running, setRunning] = useState(false);

  const [ping, setPing] = useState<PingStats | null>(null);
  const [download, setDownload] = useState<SpeedResult | null>(null);
  const [upload, setUpload] = useState<SpeedResult | null>(null);

  const [progress, setProgress] = useState<string>('');
  const abortRef = useRef<AbortController | null>(null);

  const reset = useCallback(() => {
    setPing(null);
    setDownload(null);
    setUpload(null);
    setProgress('');
  }, []);

  const measurePing = useCallback(async (count = 10, spacingMs = 200) => {
    const samples: number[] = [];
    for (let i = 0; i < count; i++) {
      const t0 = performance.now();
      await fetch(`/api/ping?ts=${Date.now()}&n=${i}`, { cache: 'no-store' });
      const t1 = performance.now();
      samples.push(t1 - t0);
      if (i < count - 1) {
        await new Promise((r) => setTimeout(r, spacingMs));
      }
    }
    const avg = samples.reduce((a, b) => a + b, 0) / samples.length;
    const min = Math.min(...samples);
    const max = Math.max(...samples);
    const mean = avg;
    const variance = samples.reduce((acc, s) => acc + Math.pow(s - mean, 2), 0) / samples.length;
    const std = Math.sqrt(variance);
    const result: PingStats = {
      samples,
      averageMs: avg,
      minMs: min,
      maxMs: max,
      jitterMs: std,
    };
    setPing(result);
    return result;
  }, []);

  const measureDownload = useCallback(async (targetSeconds = 8, partSizeBytes = 5 * 1024 * 1024) => {
    const started = performance.now();
    let totalBytes = 0;

    // Allow cancellation mid-test
    const controller = new AbortController();
    abortRef.current = controller;

    try {
      while ((performance.now() - started) / 1000 < targetSeconds) {
        const url = `/api/download?size=${partSizeBytes}&ts=${Date.now()}`;
        const res = await fetch(url, { cache: 'no-store', signal: controller.signal });

        if (!res.ok || !res.body) throw new Error('Download response invalid');

        const reader = res.body.getReader();
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            totalBytes += value.byteLength;
            const elapsed = performance.now() - started;
            setProgress(
              `Downloadingâ€¦ ${(totalBytes / (1024 * 1024)).toFixed(2)} MB in ${(elapsed / 1000).toFixed(1)} s`
            );
            if (elapsed / 1000 >= targetSeconds) {
              // Abort ongoing fetch to stop quickly
              controller.abort();
              break;
            }
          }
        }
      }
    } catch (_) {
      // Likely aborted to end the test; ignore
    } finally {
      abortRef.current = null;
    }

    const elapsedMs = performance.now() - started;
    const bps = (totalBytes * 8) / (elapsedMs / 1000);
    const result: SpeedResult = { bps, bytes: totalBytes, durationMs: elapsedMs };
    setDownload(result);
    return result;
  }, []);

  const measureUpload = useCallback(async (targetSeconds = 8, chunkBytes = 2 * 1024 * 1024) => {
    const started = performance.now();
    let totalBytes = 0;

    // Reusable random chunk to avoid CPU overhead each loop
    const base = new Uint8Array(chunkBytes);
    //crypto.getRandomValues(base);
    fillRandom(base);

    const controller = new AbortController();
    abortRef.current = controller;

    try {
      while ((performance.now() - started) / 1000 < targetSeconds) {
        // Build a ~5MB body by repeating the base chunk to amortize overhead
        const repeat = Math.ceil((5 * 1024 * 1024) / base.byteLength);
        const parts: Uint8Array[] = new Array(repeat).fill(base);
        const blob = new Blob(parts, { type: 'application/octet-stream' });

        const t0 = performance.now();
        const res = await fetch('/api/upload', {
          method: 'POST',
          body: blob,
          headers: { 'Content-Type': 'application/octet-stream' },
          cache: 'no-store',
          signal: controller.signal,
        });
        const t1 = performance.now();

        if (!res.ok) throw new Error('Upload failed');

        totalBytes += blob.size;

        const elapsed = performance.now() - started;
        const instBps = (blob.size * 8) / ((t1 - t0) / 1000);
        setProgress(
          `Uploadingâ€¦ ${(totalBytes / (1024 * 1024)).toFixed(2)} MB in ${(elapsed / 1000).toFixed(1)} s (inst ${formatBitsPerSecond(instBps)})`
        );

        if (elapsed / 1000 >= targetSeconds) {
          controller.abort();
          break;
        }
      }
    } catch (_) {
      // likely aborted
    } finally {
      abortRef.current = null;
    }

    const elapsedMs = performance.now() - started;
    const bps = (totalBytes * 8) / (elapsedMs / 1000);
    const result: SpeedResult = { bps, bytes: totalBytes, durationMs: elapsedMs };
    setUpload(result);
    return result;
  }, []);

  const start = useCallback(async () => {
    setRunning(true);
    reset();

    try {
      setProgress('Measuring pingâ€¦');
      await measurePing(10, 150);

      setProgress('Measuring download speedâ€¦');
      await measureDownload(8, 5 * 1024 * 1024);

      setProgress('Measuring upload speedâ€¦');
      await measureUpload(8, 2 * 1024 * 1024);

      setProgress('Done');
    } catch (err) {
      console.error(err);
      setProgress('Error occurred. See console.');
    } finally {
      setRunning(false);
    }
  }, [measurePing, measureDownload, measureUpload, reset]);

  const stop = useCallback(() => {
    abortRef.current?.abort();
    abortRef.current = null;
    setRunning(false);
    setProgress('Stopped');
  }, []);

  const summary = useMemo(() => {
    if (!ping && !download && !upload) return null;
    return (
      <div style={{ marginTop: 16 }}>
        {ping && (
          <div>
            <h3>Ping</h3>
            <div>Average: {formatMs(ping.averageMs)}</div>
            <div>Min: {formatMs(ping.minMs)} | Max: {formatMs(ping.maxMs)}</div>
            <div>Jitter (Ïƒ): {formatMs(ping.jitterMs)}</div>
          </div>
        )}
        {download && (
          <div style={{ marginTop: 12 }}>
            <h3>Download</h3>
            <div>Speed: {formatBitsPerSecond(download.bps)}</div>
            <div>Data: {(download.bytes / (1024 * 1024)).toFixed(2)} MB in {(download.durationMs / 1000).toFixed(1)} s</div>
          </div>
        )}
        {upload && (
          <div style={{ marginTop: 12 }}>
            <h3>Upload</h3>
            <div>Speed: {formatBitsPerSecond(upload.bps)}</div>
            <div>Data: {(upload.bytes / (1024 * 1024)).toFixed(2)} MB in {(upload.durationMs / 1000).toFixed(1)} s</div>
          </div>
        )}
      </div>
    );
  }, [ping, download, upload]);

  return (
    <main style={{ padding: 24, fontFamily: 'system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif' }}>
      <h1>Next.js Speed Test (No thirdâ€‘party libs)</h1>

      <div style={{ display: 'flex', gap: 8, marginTop: 8 }}>
        <button
          onClick={start}
          disabled={running}
          style={{ padding: '8px 12px' }}
        >
          Start Test
        </button>
        <button
          onClick={stop}
          disabled={!running}
          style={{ padding: '8px 12px' }}
        >
          Stop
        </button>
        <button
          onClick={reset}
          disabled={running}
          style={{ padding: '8px 12px' }}
        >
          Reset
        </button>
      </div>

      <div style={{ marginTop: 12, color: '#555' }}>{progress}</div>

      {summary}

      <details style={{ marginTop: 16 }}>
        <summary>Notes & Tips</summary>
        <ul>
          <li>Uses browser <code>performance.now()</code> for timing and Web Streams for I/O.</li>
          <li>Server responses set <code>Cache-Control: no-store</code> to avoid caching.</li>
          <li>Measured speeds are approximate; Wiâ€‘Fi, CPU, server/location, and tab throttling can affect results.</li>
          <li>Increase test durations (e.g., 15â€“20s) for more stable readings.</li>
          <li>You can switch API routes to <code>export const runtime = 'edge'</code> for lower latency, but Node is safer for large streams.</li>
        </ul>
      </details>
    </main>
  );
}




Hereâ€™s a **complete integration example** to get the **clientâ€™s ISP name** in a Next.js app using `ipinfo.io`.

---

### ðŸ§© What Youâ€™ll Need

- A free account at https://ipinfo.io
- Your **API token** from the dashboard

---

### âœ… Step-by-Step Integration

#### 1. **Create an API Route to Fetch IP and ISP Info**

**`app/api/isp/route.ts`**
```ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(req: NextRequest) {
  const forwarded = req.headers.get('x-forwarded-for');
  const ip = forwarded?.split(',')[0] ?? req.ip ?? 'Unknown';

  const token = process.env.IPINFO_TOKEN; // Store your token in .env.local
  const url = `https://ipinfo.io/${ip}?token=${token}`;

  try {
    const response = await fetch(url);
    const data = await response.json();

    return NextResponse.json({
      ip: data.ip,
      isp: data.org, // This contains ISP info
      city: data.city,
      region: data.region,
      country: data.country,
    });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to fetch ISP info' }, { status: 500 });
  }
}
```

---

#### 2. **Add Your Token to `.env.local`**

```env
IPINFO_TOKEN=your_ipinfo_token_here
```

> Restart your dev server after adding this.

---

#### 3. **Call the API from the Client**

**`app/page.tsx` or `pages/index.tsx`**
```tsx
'use client';
import { useEffect, useState } from 'react';

export default function Home() {
  const [info, setInfo] = useState<any>(null);

  useEffect(() => {
    fetch('/api/isp')
      .then(res => res.json())
      .then(data => setInfo(data))
      .catch(() => setInfo({ error: 'Failed to load ISP info' }));
  }, []);

  return (
    <div style={{ padding: '2rem' }}>
      <h1>Your Internet Info</h1>
      {info ? (
        <ul>
          <li><strong>IP:</strong> {info.ip}</li>
          <li><strong>ISP:</strong> {info.isp}</li>
          <li><strong>Location:</strong> {info.city}, {info.region}, {info.country}</li>
        </ul>
      ) : (
        <p>Loading...</p>
      )}
    </div>
  );
}
```

---

### ðŸ§ª Testing Tips

- Locally, you may get `127.0.0.1` or `::1`, which wonâ€™t return real ISP info.
- Use Ngrok or deploy to Vercel to test with real IPs.

---

Would you like help deploying this to Vercel or setting up Ngrok for testing?
